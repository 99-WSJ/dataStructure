## 登录

#### Cookie

* 是服务器发送到浏览器（响应里面有个setcookie属性），并保存在浏览器端的一小块数据，比如用户名
* 浏览器下次访问该服务器时，会**自动**携带块该数据，将其发送给服务器
* 客户端，默认4kb太小，安全风险容易篡改，浏览器也可能禁用cookie

#### Session

* 服务器响应里面有个setcookie属性，设置为sessionId，后面在请求的时候会自动添加sessionId

登录问题：

* 首先登录模块主要是web端和小程序端的；共用一套后端；都是实现redis保存token、图片验证码和手机验证码登录的功能，并且在这个基础上进行限流。如何使用redis保存呢，登录有用户名，密码，图片验证码；和手机号、手机验证码、图片验证码两种，redis主要是保存这两个验证码，先说第一种用户名登录的情况，当访问登陆页面，后端生成图片验证码，保存到redis里面（string类型，用生成的UUID作为key来命名，同时这个key放到cookie里面并设置cookie有效期1分钟），同时返回给前端，前端输入用户名密码和验证码后提交表单，后端接收后，首先看刚刚保存在cookie里面的key有没有过期，然后在redis里面获取这个key的值，进行比较看验证码是否正确；如果正确之后，再从数据库里面比较用户名和密码，这里的密码使用了随机盐加MD5加密的方式存储；至于手机验证码登录，同样是存入redis里面，进行比较。
* 需要注意的是，图片验证码是可以重复刷新的，手机验证码要隔一分钟，这里采用的是redis里面的set nx命令，如果key存在，没过期的话，就不能发送。如果redis出现问题没有存的话，比较两次生成的时间。**再不济放入mysql中**
* **问题：**如果出现存入redis失败的情况；这个时候可以把验证码存入mysql，或者让用户可以重新尝试发一次。
* 怎么维护登陆状态，一开始是使用一张表login_ticket记录是否处于登录状态，有一个字段为status，登陆的时候将状态设为1，退出登录就设置为0；在这个登录基础上，将登录凭证对象存到redis里面（String类型），key是随机生成的UUID，定义为凭证ID，value就是登陆凭证对象；这里不设置过期时间，因为会对商户每天登陆的情况进行奖励，如果之前的记录删除了，就不好统计了；同时在cookie里面设置ticket属性，存的是刚刚随机生成的UUID。同时配置相关的拦截器，这样每次访问的时候都可以在拦截器中，获取cookie里面的凭证ID，在拦截器中检查凭证对象是否有效，如果有效的话，再查userId，然后在hostHolder里面持有该用户。HostHolder用于多线程环境下，持有用户信息。

#### 限流问题

* 检查账号密码是否频繁登录，需要借助redis的zset数据结构，设计一个时间窗口限流算法实现（登录，点赞，评论等），进行限流，避免对数据库造成压力
* 窗口限流：定义一个窗口和登录限制次数；
* 当用户每次发生限流行为，都会记录这个行为，以 Redis zset的方式进行记录
* 调用redis的zcount（ZCOUNT key min max）命令，这个命令可以传入起始分值和结束分值。我就把当前时间戳作为结束分值，然后当前时间戳减去限流时间，比如说15分钟的窗口，登录次数就是这15分钟的记录次数；如果超过15就限流，不发验证码给客户端，暂时不能登录

#### 查询问题：

* 查询货品，进货的时候一般是凌晨三四点，而且是很多商家一起，同一时间段从供应商那边进货。进货（插入）的同时存入redis。因为后面查用的次数比较频繁，所以这里也使用redis，优先从缓存中取值（商品id，商品名字，数量，价格，时间等），取不到的时候从Mysql里面查数据，初始化缓存数据；这里使用了布隆过滤器（分流，bitmap和多个哈希函数实现），判断redis是否缓存对应的数据；
* sql方面，优化sql查询

#### Lua 脚本

* 判断兑换礼品库存是否充足且一人只能兑换一次
* 在lua脚本中编写多条Redis命令，redis会将整个脚本作为一个整体执行，中间不会被其他请求打断
* 当redis同时收到多个请求时，由于Redis 命令的执行采用的是单线程模型，它会一个一个的去执行当前lua脚本（放在一个队列里面），其他的请求就会阻塞。（Redis不会进行回滚，aof和RDB持久化）
* 这里采用的redis服务器是一主多从的，如果是多主多从就不能保证原子性了

#### 定时传输

* 涉及到数据安全的问题，每天定时传输数据库数据到静安服务器

#### 文件上传

* 压缩，分块，多线程，断点续传





1、检验账号：web端账号密码、小程序是手机验证码

前后端分离的项目，数据以JSON 的方式进行请求和响应，当收到请求的时候，会校验账号和密码以及验证码参数；

* 首先前端检验参数是否合法（手机号码是否11位，密码格式），是否非空；失败就直接返回失败信息，重新回到登陆页面
* 手机验证码可以限制次数，比如一分钟一次，使用set ex或者set nx过期时间，检验验证码是否正确，在redist里面存的验证码和用户比对， 
* 参数没问题的话，检查账号密码是否频繁登录，需要借助redis的zset数据结构，设计一个时间窗口限流算法实现（登录，点赞，评论等），进行限流，避免对数据库造成压力
* 如果没有限流，就查询用户数据，检查是否存在，并进行密码校验，这里检验密码的时候，使用了一个随机盐的一个工具类BCrypt实现，安全度较高

2、前后端测试： Postman  可以创建团队，把接口写好了之后放在团队里面

3、调用ES进行搜索，为什么不用mysql，主要是模糊查询，容易不走索引，查询效率很低，需要随机IO，性能比较低；ES可以进行分词索引，只需将信息放进ES服务器中，查询时可以返回需要的内容

4、ThreadLocal:保存用户线程信息，后续的controller，sevice 就可以随时随地获取用户信息

5、部署项目：

６、SQL查询并优化

７、实现方式很简单，我们提前购买了IP 地址数据的省级离线库 ® https://user.ip138.com/ip/lib/我们是在发布的时候，从请求头中获取到客户端IP 地址信息，然后查询数据库中的数据，得到发布的地点，随着文章或评论一起保存到数据库表中就可以了。

8、Single Sign-O ： 单点登录，允许用户只需要一次登录就能够访问多个独立的应用程序或系统。

通常情况下，一个用户需要为每个应用程序或系统提供不同的用户名和密码进行登录。然而，使用SSO，用户只需在一个集中的身份认证系统中登录一次，该系统会提供一个令牌（token）给用户，表示用户已经通过身份验证。然后，用户可以使用这个令牌来访问其他受信任的应用程序或系统，而不需要再次提供用户名和密码。

