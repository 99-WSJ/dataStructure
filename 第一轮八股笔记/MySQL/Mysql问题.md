## MySQL 问题

1、NULL和‘ ’的区别是什么

* NULL代表一个不确定的值，‘ ’的长度为0，不占用空间
* `NULL` 代表一个不确定的值,就算是两个 `NULL`,它俩也不一定相等。例如，`SELECT NULL=NULL`的结果为 false，但是在我们使用`DISTINCT`,`GROUP BY`,`ORDER BY`时,`NULL`又被认为是相等的。
* `''`的长度是 0，是不占用空间的，而`NULL` 是需要占用空间的。
* `NULL` 会影响聚合函数的结果。例如，`SUM`、`AVG`、`MIN`、`MAX` 等聚合函数会忽略 `NULL` 值。 `COUNT` 的处理方式取决于参数的类型。如果参数是 (`COUNT(*)`)，则会统计所有的记录数，包括 `NULL` 值；如果参数是某个字段名(`COUNT(列名)`)，则会忽略 `NULL` 值，只统计非空值的个数。
* 查询 `NULL` 值时，必须使用 `IS NULL` 或 `IS NOT NULLl` 来判断，而不能使用 =、!=、 <、> 之类的比较运算符。而`''`是可以使用这些比较运算符的

2、drop truncate delete概念、用法和区别（内容，是否回滚）

* ```TXT
  drop 删除表的结构和内容，结构删除后，表就不存在了
  truncate 删除表的内容，只是清空不会删除表的结构；如果在插入，自增id从1开始
  delete 删除表的内容，可以带where语句删除具体哪一行，不会删除表的结构
  drop和truncate 属于DDL 不可回滚
  delete 属于DML， 可以回滚；事务提交后才生效
  
  一般来说：速度上drop 》 truncate 》 delete，但是delete可以回滚，有日志，较安全
  ”“”
  Rollback Segment：在数据库管理系统中，一个rollback segment是一块专门的存储区域，用于存储已经提交但尚未持久化到数据库文件中的数据修改操作。这些数据修改操作包括insert、update、delete等。
  
  事务：数据库中的事务是一系列数据库操作，被视为一个单独的逻辑单元，并且要么全部执行成功，要么全部失败回滚。事务通过BEGIN TRANSACTION开始，通过COMMIT TRANSACTION提交，或者通过ROLLBACK TRANSACTION回滚。
  
  提交事务：当执行一个事务时，所有的数据修改操作可能都会被记录到rollback segment中，而不会立即应用到数据库文件中。只有在执行COMMIT TRANSACTION提交事务之后，这些修改才会被写入数据库文件，从而实际地改变了数据库中的数据。如果在事务提交之前发生了错误或者执行了ROLLBACK TRANSACTION，那么rollback segment中的数据修改会被撤销，数据库中的数据状态会回滚到事务开始之前的状态。
  
  所以，当说一个操作"放到 rollback segment 中，事务提交之后才生效"时，意味着该操作对数据库的修改并不会立即生效，而是在事务提交时才会实际应用到数据库中。
  “”“
  
  ```

3、存储过程概念，优点，为什么不用

* 概念：一系列SQL操作的批处理

* 代码封装，保证了一定的安全性；代码复用；速度快，预编译的；
* 但是没有移植性，难以调试和扩展

4、三大范式（非主属性、ER图）

* ```txt
  元组 ==> 行数据或者说一条记录；每列（字段）就是一个属性
  码 ==> 列或者属性 字段
  候选码 ==> 若关系中的某一属性或属性组的值能唯一的标识一个元组，其子集也不能标识，说明该属性或者属性组为候选码
  主码：也叫主键，从候选码中选择出来的，
  外码：也叫外键，如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码
  主属性：候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。非主属性： 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。
  
  ```

* ```txt
  ER 图 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。
  在 ER 图中，实体使用矩形框表示。
  在 ER 图中，属性使用椭圆形表示。
  在 ER 图中，联系（实体与实体之间的关系）用菱形表示
  ```

* 三大范式

* 1NF(第一范式)：属性不可再分。

  2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。

  3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。

5、主键和外键的区别

* ```txt
  主键：用于唯一标识一个元组，不能有重复，不能为空，一张表只能有一个
  外键：外键是另一张表的主键，外键是可以重复的，可以是空值，一个表可以有多个外键
  ```

* 为什么不推荐使用外键：并发量不高的情况下可以使用

* ```txt
  1、增加了复杂性，比如删除或者更新都要考虑到外键约束
  2、维护外键工作的成本
  3、对分库分表不友好，无法生效
  ```

6、视图

* 定义：

  - 视图是基于 SQL 语句的结果集的可视化的表。
  - 视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。

  作用：

  - 简化复杂的 SQL 操作，比如复杂的联结；
  - 只使用实际表的一部分数据；
  - 通过只给用户访问视图的权限，保证数据的安全性；
  - 更改数据格式和表示。

7、索引（INDEX）

* 索引是一种快速查询和检索数据的一种数据结构

* 优点

  ```txt
  使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）,减少随机IO次数 这也是创建索引的最主要的原因。
  
  通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
  ```

* 缺点

* ```txt
  创建索引和维护索引需要耗费时间，当表中的数据进行增删改的时候，如果有索引那么索引也需要动态的修改，会降低SQL执行效率
  
  索引需要物理空间存储，会耗费一定空间
  ```

* 大多数情况下，使用索引能够提高查询性能；如果数据量不大，不一定能带来很大提升

8、约束

* 1、约束类型：
  - `NOT NULL` - 指示某列不能存储 NULL 值。
  - `UNIQUE` - 保证某列的每行必须有唯一的值。
  - `PRIMARY KEY` - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。
  - `FOREIGN KEY` - 保证一个表中的数据匹配另一个表中的值的参照完整性。
  - `CHECK` - 保证列中的值符合指定的条件。
  - `DEFAULT` - 规定没有给列赋值时的默认值


9、事务：**事务是逻辑上的一组操作，要么都执行，要么都不执行**

* 不能回退 `SELECT` 语句，回退 `SELECT` 语句也没意义；也不能回退 `CREATE` 和 `DROP` 语句。

* **MySQL 默认是隐式提交**，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 `START TRANSACTION` 语句时，会关闭隐式提交；当 `COMMIT` 或 `ROLLBACK` 语句执行后，事务会自动关闭，重新恢复隐式提交。

  通过 `set autocommit=0` 可以取消自动提交，直到 `set autocommit=1` 才会提交；`autocommit` 标记是针对每个连接而不是针对服务器的。

  指令：

  - `START TRANSACTION` - 指令用于标记事务的起始点。
  - `SAVEPOINT` - 指令用于创建保留点。
  - `ROLLBACK TO` - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 `START TRANSACTION` 语句处。
  - `COMMIT` - 提交事务。

10、游标（后面了解）

11、触发器（后面了解）

12、InnoDB和MyISAM区别

* MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB

* ![image-20240415134410880](C:/Users/WSJ/Desktop/704Sync_dataStructure/dataStructure/%E7%AC%AC%E4%B8%80%E8%BD%AE%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0/MySQL/Mysql%E9%97%AE%E9%A2%98.assets/image-20240415134410880.png)

* **1.是否支持行级锁**

  MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。

  **2.是否支持事务**

  MyISAM 不提供事务支持。

  InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。

  关于 MySQL 事务的详细介绍，可以看看我写的这篇文章：[MySQL 事务隔离级别详解]()。

  **3.是否支持外键**

  MyISAM 不支持，而 InnoDB 支持。

  **4.是否支持数据库异常崩溃后的安全恢复**

  MyISAM 不支持，而 InnoDB 支持。

  使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 `redo log` 。

  **5.是否支持 MVCC**

  MyISAM 不支持，而 InnoDB 支持。

  讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。

  **6.索引实现不一样。**

  虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。

  InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。

  详细区别，推荐你看看我写的这篇文章：[MySQL 索引详解]()。

  **7.性能有差别。**

  InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。

13、Mysql在8.0版本后移除了查询缓存

14、事务：逻辑上的一组操作，要么执行，要么不执行

15、事务的ACID特性

* 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
* 一致性：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
* 隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
* 持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

* ```txt
  原子性（Atomicity）
  一致性（Consistency）
  隔离性（Isolation）
  持久性（Durability）
  
  只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！
  ```

16、脏读、丢失修改、不可重复读、幻读

* **丢失修改：**事务A访问该数据，事务B也访问该数据，事务A修改了该数据，事务B也修改了该数据，这样导致事务A的修改被丢失，因此称为丢失修改；

17、四种隔离级别：

* **读未提交（Read Uncommitted）**：在这个级别下，一个事务可以看到其他事务尚未提交的修改。这意味着一个事务可以读取到其他事务未完成的、甚至是脏数据。这种隔离级别下，事务并不会加锁，因此可能导致脏读（Dirty Read）的问题。
* ![image-20240416095709435](C:/Users/WSJ/Desktop/704Sync_dataStructure/dataStructure/%E7%AC%AC%E4%B8%80%E8%BD%AE%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0/MySQL/Mysql%E9%97%AE%E9%A2%98.assets/image-20240416095709435.png)
* **读已提交（Read Committed）**：在这个级别下，一个事务只能看到已经提交的其他事务所做的修改。这就避免了脏读的问题，因为事务只能读取到已经提交的数据。然而，由于其他事务可能在此期间提交新的数据，所以可能会出现不可重复读（Non-Repeatable Read）的问题。
* ![image-20240416095745210](C:/Users/WSJ/Desktop/704Sync_dataStructure/dataStructure/%E7%AC%AC%E4%B8%80%E8%BD%AE%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0/MySQL/Mysql%E9%97%AE%E9%A2%98.assets/image-20240416095745210.png)
* **可重复读（Repeatable Read）**：在这个级别下，一个事务在执行期间看到的数据保持一致，即使其他事务对数据进行了修改也不会影响。这意味着如果一个事务读取了一行数据，在事务结束之前，其他事务对该行数据进行修改不会被该事务看到。但是，可能会出现幻读（Phantom Read）的问题，即在同一事务内，相同的查询在不同的时间点返回了不同的结果集。
* ![image-20240416095910622](C:/Users/WSJ/Desktop/704Sync_dataStructure/dataStructure/%E7%AC%AC%E4%B8%80%E8%BD%AE%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0/MySQL/Mysql%E9%97%AE%E9%A2%98.assets/image-20240416095910622.png)
* **串行化（Serializable）**：这是最严格的隔离级别，在这个级别下，事务按照其提交的顺序依次执行，事务之间完全隔离。它避免了所有可能的并发问题，但是性能开销也是最大的。

18、比较

* 不可重复读和幻读区别

* ```txt
  1、幻读可以是不可重复读的特殊情况，都是说A事务读取后B事务进行了一定操作（修改和删除插入），使得A事务再次读取出现了数据不一致的情况
  2、不可重复读：主要是修改操作，数据内容不一样
  3、幻读主要是：新增和删除，数据条数不一样
  ```

* 当多个事务同时操作，就会出现脏读、可重复读、幻读；于是有了隔离级别的出现