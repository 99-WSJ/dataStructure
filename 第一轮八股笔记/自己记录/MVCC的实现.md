ReadView 其实就是一个保存事务ID的list列表。记录的是本事务执行时，MySQL还有哪些事务在执行，且还没有提交。(当前系统中还有哪些活跃的读写事务)

它主要包含这样几部分：

- m_ids，当前有哪些事务正在执行，且还没有提交，这些事务的 id 就会存在这里；
- min_trx_id，是指 m_ids 里最小的值；
- max_trx_id，是指下一个要生成的事务 id。下一个要生成的事务 id 肯定比现在所有事务的 id 都大；
- creator_trx_id，每开启一个事务都会生成一个 ReadView，而 creator_trx_id 就是这个开启的事务的 id。

这样在访问某条记录时，只需要按照下边的步骤判断该记录在版本链中的某个版本（trx_id）是否可见：
     **1**、trx_id < m_ids列表中最小的事务id
     表明生成该版本的事务在生成ReadView前已经提交，所以该版本可以被当前事务访问。
     **2**、trx_id > m_ids列表中最大的事务id
     表明生成该版本的事务在生成ReadView 后才生成，所以该版本不可以被当前事务访问。
     **3**、m_ids列表中最小的事务id ≤ trx_id ≤ m_ids列表中最大的事务id（可以取等于，感谢网友指出）
     此处比如m_ids为[5,6,7,9,10]
     **①**、若trx_id在m_ids中，比如是6，可以分成2种情况

​        a. creator_trx_id也是6，说明这条trx_id记录是当前事务产生的，可以被访问

​        a. creator_trx_id不是6，说明这条trx_id记录**不是**当前事务产生的，并且创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问。
​     **②**、若trx_id不在m_ids中，比如是8：说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。

**一句话说：当trx_id在m_ids中且creator_trx_id** != **trx_id，或者大于m_ids列表中最大的事务id的时候，这个版本就不能被访问。**





读分为当前读和快照读，快照读交给MVCC处理，当前读是根据间隙锁

#### MVCC 实现RC和RR

#### 1、RC级别下：基于undo.log 能解决脏读，不能解决可重复读

* RC级别下，每次select的时候生成一个新的readview，脏读事务会出现在活跃事务id列表中，mvcc机制下读取不到，所以可以避免脏读，但是如果修改事务在两次查询之间提交了，那么第二次的readview里面的活跃id列表中就不会出现修改事务的id，这样两次读取的结果不一样，所以导致了不可重复读

#### 2、 RR级别下：基于undo.log 能解决脏读、可重复读，不能解决幻读

* RR级别下，当前事务不管select多少次，都只会在第一个select情况下生成唯一一个readview，当修改事务提交后，当前事务再次select，仍然使用的是同一个readview，这样修改事务虽然已经提交，但是仍然在活跃列表中，读取不到最新的值，只能读修改前的数据，这样就避免了不可重复读；**但这种方法能解决快照读，却无法锁住insert的数据（当前读）。**

#### 当前读和快照读

* 快照读：读取的是记录数据的可见版本（可能是过期的数据），不用加锁（**但是其他事务可以插入**），select时为快照读。MVCC实现。不需要竞争锁。

* 当前读：读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录。update、insert、delete 都是当前读。排它锁

* 这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库最新版本数据的方式，叫当前读 (current read)。

* 当前读 

* ```txt
  它读取的数据库记录，都是当前最新的版本，会对当前读取的数据进行加锁，防止其他事务修改数据:是悲观的一种操作
  
  select lock in share mode (共享锁)
  select for update (排他锁)
  update (排他锁)
  insert(排他锁)
  delete (排他锐)
  串行化亭务隔离级别
  ```

* 一般在开发过程中建议开启一个事务时尽快采用for update的查询方式，以生成next-key lock，避免幻读问题。

### 四、如何解决幻读

在快照读情况下，mysql通过mvcc来避免幻读。

在当前读情况下，mysql通过X锁或next-key来避免其他事务修改:

- 使用串行化读的隔离级别
- (update、delete)当where条件为主键时，通过对主键索引加record locks(索引加锁/行锁)处理幻读。
- (update、delete)当where条件为非主键索引时，通过next-key锁处理。next-key是record locks(索引加锁/行锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)的结合。
- 即便是给每行数据都加上行锁，也无法解决幻读，行锁只能阻止修改，无法阻止数据的删除。而且新插入的数据，自然是[数据库](https://link.csdn.net/?target=https%3A%2F%2Fgitcode.com%2FSequoiaDB%2FSequoiaDB%2Foverview%3Flogin%3Dfrom_csdn)中不存在的数据，原本不存在的数据自然无法对其加锁，因此仅仅使用行锁是无法阻止别的事务插入数据的。

##　undo log 两大作用：

- **实现事务回滚，保障事务的原子性**。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。
- **实现 MVCC（多版本并发控制）关键因素之一**。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通  select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。
