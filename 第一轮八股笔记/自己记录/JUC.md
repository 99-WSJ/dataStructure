# JUC 

#### 进程与线程的区别总结：

    本质区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。
    
    包含关系：一个进程至少有一个线程，线程是进程的一部分。
    
    资源开销：每个进程都有独立的地址空间，进程之间的切换会有较大的开销；同一个进程内的线程共享进程的地址空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。
    
    影响关系：一个进程崩溃后，在保护模式下其他进程不会被影响，但是一个线程崩溃可能导致整个进程被操作系统杀掉，所以多进程要比多线程健壮
#### 并行和并发

* **前提：一个CPU在一个瞬间只能处理一个任务**

* ![image-20240428130335837](C:/Users/WSJ/Desktop/704Sync_dataStructure/dataStructure/%E7%AC%AC%E4%B8%80%E8%BD%AE%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%B7%B1%E8%AE%B0%E5%BD%95/JUC.assets/image-20240428130335837.png)

* ![image-20240428130449794](C:/Users/WSJ/Desktop/704Sync_dataStructure/dataStructure/%E7%AC%AC%E4%B8%80%E8%BD%AE%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%B7%B1%E8%AE%B0%E5%BD%95/JUC.assets/image-20240428130449794.png)

* 所谓的进程上下文，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈上的内容，当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。

* 1、并发：并发是指两个或多个事件在同一时间间隔发生，把任务在[不同的](https://so.csdn.net/so/search?q=不同的&spm=1001.2101.3001.7020)时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。

  2、并行：并行是指两个或者多个事件在同一时刻发生，把每一个[任务分配](https://so.csdn.net/so/search?q=任务分配&spm=1001.2101.3001.7020)给每一个处理器独立完成。在同一时间点，任务一定是同时运行。

* 用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。

* 内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。

#### 如何创建线程

* 继承thread类
* 实现Runable类
* 实现callable接口
* 使用ExecutorService线程池
* 使用`CompletableFuture`类
* 基于`ThreadGroup`线程组；
*  使用`FutureTask`类。

死锁的四个必要条件：**互斥、占有且等待、不可强占用、循环等待**

#### start() 和 run()区别

* run 方法是线程的执行体，包含线程要执行的代码，当直接调用run 方法时，它会在当前线程的上下文中执行，而不会创建新的线程。
* start 方法用于启动一个新的线程，并在新线程中执行run 方法的代码。调用 start 方法会为线程分配系统资源，并将线程置于就绪状态，当调度器选择该线程时，会执行 run 方法中的代码。
* 因此，虽然可以直接调用 run 方法，但这并不会创建一个新的线程，而是在当前线程中执行 run 方法的代码。如果需要实现多线程执行，则应该调用 start方法来启动新线程

#### 线程的生命周期

![image-20240510153326116](C:/Users/WSJ/Desktop/704Sync_dataStructure/dataStructure/%E7%AC%AC%E4%B8%80%E8%BD%AE%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%B7%B1%E8%AE%B0%E5%BD%95/JUC.assets/image-20240510153326116.png)

1、新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread()；

2、就绪状态（ Runnable） ：当调用线程对象的start()方法（t.start();）， 线程即进入就绪状态。处于就绪状态的线程， 只是说明此线程已经做好了准备，随时等待CPU 调度执行，并不是说执行了t.start()此线程立即就会执行；

3、运行状态（ Running）：当CPU 开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口， 也就是说，线程要想进入运行状态执行， 首先必须处于就绪状态中；

4、阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU 调用以进入到运行状态。

根据阻塞产生的原因不同，阻塞状态又可以分为三种：

    等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；
    同步阻塞：线程在获取synchronized 同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；
    其他阻塞：通过调用线程的sleep()或join()或发出了I/O 请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O 处理完毕时， 线程重新转入就绪状态。

5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期

#### 如何预防和避免线程死锁?

#### JMM(内存模型)

#### volatile 关键字

* 保证变量的可见性，但不能保证数据的原子性；`synchronized` 关键字两者都能保证。
* 防止 JVM 的指令重排序

#### 乐观锁和悲观锁

#### 如何实现乐观锁：版本号机制或 CAS 算法

* 每次对数据进行修改时，都会读取数据的版本号。更新数据时将版本号加一。在提交更新时，事务会将新的版本号一并提交到数据库中。在并发访问时，如果另一个事务在读取数据和版本号后并提交，发现数据的版本号已经发生了变化，说明有其他事务已经修改了数据，那么更新失败。
* **Compare And Swap（比较与交换）**
* CAS 涉及到三个操作数：
  - **V**：要更新的变量值(Var)
  - **E**：预期值(Expected)
  - **N**：拟写入的新值(New)
* ABA，失败的线程会一直循环运行
* 解决ABA
* CAS 只对单个共享变量有效，可以使用锁或者利用`AtomicReference`类把多个共享变量合并成一个共享变量来操作

#### synchronized

1. 修饰实例方法
2. 修饰静态方法
3. 修饰代码块

构造方法不能使用 synchronized 关键字修饰。不过，可以在构造方法内部使用 synchronized 代码块。

另外，构造方法本身是线程安全的，但如果在构造方法中涉及到共享资源的操作，就需要采取适当的同步措施来保证整个构造过程的线程安全。

#### synchronized 同步语句块的情况

* `synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令
* `monitorenter` 指令指向同步代码块的开始位置
* `monitorexit` 指令则指明同步代码块的结束位置
* `wait/notify`等方法也依赖于`monitor`对象，这就是为什么只有在同步的块或者方法中才能调用`wait/notify`等方法，否则会抛出`java.lang.IllegalMonitorStateException`的异常的原因。

#### synchronized 修饰方法的的情况

* `synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。JVM 通过该 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。
* 如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。

#### synchronized 和 volatile 有什么区别

`synchronized` 关键字和 `volatile` 关键字是两个互补的存在，而不是对立的存在！

- `volatile` 关键字是线程同步的轻量级实现，所以 `volatile`性能肯定比`synchronized`关键字要好 。但是 `volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块 。
- `volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。
- `volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。

